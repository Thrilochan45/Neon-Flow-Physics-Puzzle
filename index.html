<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Flow: Physics Puzzle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            background-color: #050505;
            color: #ffffff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Prevent swipe navigation */
            user-select: none;
        }
        
        canvas {
            display: block;
            touch-action: none;
        }

        .neon-text {
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff, 0 0 20px #00f;
        }

        .neon-border {
            box-shadow: 0 0 5px #0ff, inset 0 0 5px #0ff; 
            border: 1px solid #0ff;
        }

        .neon-btn {
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid #0ff;
            color: #0ff;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 5px #0ff;
        }

        .neon-btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
        }
        
        .neon-btn:active {
            transform: scale(0.95);
        }

        /* Overlay Styles */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas usually */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        /* Modal */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        
        .modal-content {
            background: rgba(10, 10, 20, 0.95);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            border: 1px solid #0ff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
            max-width: 90%;
            width: 400px;
            transform: translateY(20px);
            transition: transform 0.3s ease;
        }

        .modal.active .modal-content {
            transform: translateY(0);
        }

        #ink-bar-container {
            width: 200px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid #555;
        }

        #ink-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #f0f, #0ff);
            width: 100%;
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <!-- Top HUD -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div>
                <h1 class="text-2xl neon-text tracking-widest text-cyan-400">NEON FLOW</h1>
                <div class="text-sm text-gray-400 mt-1">Level: <span id="level-display" class="text-white font-bold">1</span></div>
            </div>
            <div class="flex flex-col items-end gap-2">
                <div class="flex items-center gap-2">
                    <span class="text-xs uppercase text-cyan-300 tracking-wider">Ink Level</span>
                    <div id="ink-bar-container">
                        <div id="ink-bar-fill"></div>
                    </div>
                </div>
                <button onclick="clearLines()" class="neon-btn px-3 py-1 text-xs rounded">
                    <i class="fas fa-undo mr-1"></i> Clear Lines
                </button>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="flex justify-center items-end pb-4 pointer-events-auto">
            <button id="drop-btn" onclick="togglePlay()" class="neon-btn px-8 py-4 rounded-full text-xl font-bold bg-black bg-opacity-50">
                <i class="fas fa-play mr-2"></i> DROP BALL
            </button>
        </div>
    </div>

    <!-- Start/Instructions Modal -->
    <div id="start-modal" class="modal active">
        <div class="modal-content">
            <h2 class="text-4xl neon-text mb-4 text-cyan-400">NEON FLOW</h2>
            <p class="text-gray-300 mb-6 leading-relaxed">
                Use your logic and creativity to guide the ball.<br><br>
                <i class="fas fa-pen-fancy text-fuchsia-400"></i> <b>Draw lines</b> to create paths.<br>
                <i class="fas fa-tint text-cyan-400"></i> Watch your <b>Ink Limit</b>.<br>
                <i class="fas fa-star text-yellow-400"></i> Collect <b>Stars</b> for points.<br>
                <i class="fas fa-bullseye text-green-400"></i> Reach the <b>Portal</b>.
            </p>
            <button onclick="startGame()" class="neon-btn px-8 py-3 rounded text-lg font-bold w-full">
                START GAME
            </button>
        </div>
    </div>

    <!-- Level Complete Modal -->
    <div id="win-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-3xl neon-text mb-2 text-green-400">LEVEL COMPLETE!</h2>
            <div class="flex justify-center gap-2 text-3xl my-4 text-yellow-400" id="star-display">
                <i class="far fa-star"></i><i class="far fa-star"></i><i class="far fa-star"></i>
            </div>
            <p id="win-message" class="text-gray-300 mb-6">Perfect flow!</p>
            <button onclick="nextLevel()" class="neon-btn px-8 py-3 rounded text-lg font-bold w-full">
                NEXT LEVEL <i class="fas fa-arrow-right ml-2"></i>
            </button>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="fail-modal" class="modal">
        <div class="modal-content">
            <h2 class="text-3xl neon-text mb-2 text-red-500">OOPS!</h2>
            <p class="text-gray-300 mb-6">The ball was lost to the void or hit a spike.</p>
            <button onclick="retryLevel()" class="neon-btn px-8 py-3 rounded text-lg font-bold w-full">
                TRY AGAIN <i class="fas fa-redo ml-2"></i>
            </button>
        </div>
    </div>

    <script>
        // --- Game Constants & Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // --- Audio System (Simple Synth) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'bounce') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'win') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.2);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.5);
            } else if (type === 'star') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            }
        }

        // --- Physics & Game Objects ---
        
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vector(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vector(this.x * n, this.y * n); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            norm() { let m = this.mag(); return m === 0 ? new Vector(0,0) : new Vector(this.x/m, this.y/m); }
            dist(v) { return Math.sqrt((this.x - v.x)**2 + (this.y - v.y)**2); }
            dot(v) { return this.x * v.x + this.y * v.y; }
        }

        class Ball {
            constructor(x, y) {
                this.startPos = new Vector(x, y);
                this.pos = new Vector(x, y);
                this.vel = new Vector(0, 0);
                this.radius = 12;
                this.active = false;
                this.color = '#0ff';
                this.trail = [];
            }

            reset() {
                this.pos = new Vector(this.startPos.x, this.startPos.y);
                this.vel = new Vector(0, 0);
                this.active = false;
                this.trail = [];
            }

            update() {
                if (!this.active) return;

                // Gravity
                this.vel = this.vel.add(new Vector(0, 0.4));
                // Air resistance
                this.vel = this.vel.mult(0.995);
                
                // Max speed cap
                const maxSpeed = 15;
                if(this.vel.mag() > maxSpeed) {
                    this.vel = this.vel.norm().mult(maxSpeed);
                }

                this.pos = this.pos.add(this.vel);

                // Trail effect
                this.trail.push({x: this.pos.x, y: this.pos.y, alpha: 1.0});
                if (this.trail.length > 20) this.trail.shift();
                this.trail.forEach(t => t.alpha -= 0.05);

                // Check bounds (fail)
                if (this.pos.y > height + 50 || this.pos.x < -50 || this.pos.x > width + 50) {
                    failLevel();
                }
            }

            draw(ctx) {
                // Draw Trail
                for (let i = 0; i < this.trail.length - 1; i++) {
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(0, 255, 255, ${this.trail[i].alpha * 0.5})`;
                    ctx.lineWidth = this.radius * (i / this.trail.length);
                    ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    ctx.lineTo(this.trail[i+1].x, this.trail[i+1].y);
                    ctx.stroke();
                }

                // Draw Ball
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Inner White Core
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }
        }

        class Wall {
            constructor(x1, y1, x2, y2) {
                this.p1 = new Vector(x1, y1);
                this.p2 = new Vector(x2, y2);
                this.color = '#f0f'; // Magenta for user lines
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 4;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.lineCap = 'round';
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
        }

        class Obstacle {
            constructor(x, y, w, h, type) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.type = type; // 'solid' (static wall) or 'spike' (kill)
            }

            draw(ctx) {
                ctx.fillStyle = this.type === 'spike' ? '#f00' : '#444';
                ctx.shadowBlur = this.type === 'spike' ? 15 : 0;
                ctx.shadowColor = '#f00';
                
                if (this.type === 'spike') {
                    // Draw spikes
                    ctx.beginPath();
                    const spikesCount = Math.floor(this.w / 10);
                    for(let i=0; i<spikesCount; i++) {
                        ctx.moveTo(this.x + i*10, this.y + this.h);
                        ctx.lineTo(this.x + i*10 + 5, this.y);
                        ctx.lineTo(this.x + i*10 + 10, this.y + this.h);
                    }
                    ctx.fill();
                } else {
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                    // Tech border
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(this.x, this.y, this.w, this.h);
                }
                ctx.shadowBlur = 0;
            }
        }

        class Goal {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.radius = 25;
                this.angle = 0;
            }

            draw(ctx) {
                this.angle += 0.05;
                
                // Outer glow
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#0f0';
                
                // Rotating rings
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 3;
                
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius, this.angle, this.angle + Math.PI * 1.5);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * 0.7, -this.angle, -this.angle + Math.PI * 1.5);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
                
                // Center text
                ctx.fillStyle = '#fff';
                ctx.font = '12px Orbitron';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('GOAL', this.pos.x, this.pos.y);
            }
        }

        class Star {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.collected = false;
                this.floatOffset = Math.random() * Math.PI * 2;
            }

            draw(ctx) {
                if (this.collected) return;
                const floatY = Math.sin(Date.now() / 500 + this.floatOffset) * 5;
                
                ctx.fillStyle = '#ff0';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff0';
                
                // Draw Star Shape
                ctx.beginPath();
                const spikes = 5;
                const outerRadius = 10;
                const innerRadius = 5;
                
                let rot = Math.PI / 2 * 3;
                let x = this.pos.x;
                let y = this.pos.y + floatY;
                let step = Math.PI / spikes;

                ctx.moveTo(this.pos.x, this.pos.y + floatY - outerRadius);
                for (let i = 0; i < spikes; i++) {
                    x = this.pos.x + Math.cos(rot) * outerRadius;
                    y = this.pos.y + floatY + Math.sin(rot) * outerRadius;
                    ctx.lineTo(x, y);
                    rot += step;

                    x = this.pos.x + Math.cos(rot) * innerRadius;
                    y = this.pos.y + floatY + Math.sin(rot) * innerRadius;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(this.pos.x, this.pos.y + floatY - outerRadius);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.pos = new Vector(x, y);
                this.vel = new Vector((Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5);
                this.life = 1.0;
                this.color = color;
            }
            update() {
                this.pos = this.pos.add(this.vel);
                this.life -= 0.05;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // --- Game State Variables ---
        let currentLevel = 0;
        let ball, goal;
        let walls = []; // User drawn lines
        let obstacles = []; // Level static obstacles
        let stars = [];
        let particles = [];
        let isDrawing = false;
        let lastDrawPos = null;
        let inkRemaining = 100;
        const maxInk = 100;
        let isSimulating = false;
        let starsCollectedInRun = 0;
        
        const levels = [
            // Level 1: The Drop (Tutorial)
            {
                start: {x: 100, y: 100},
                goal: {x: 100, y: 500},
                ink: 100,
                obstacles: [
                    {x: 200, y: 200, w: 20, h: 200, type: 'solid'} // Just a visual decoration
                ],
                stars: [{x: 100, y: 300}]
            },
             // Level 2: The Ramp
             {
                start: {x: 50, y: 100},
                goal: {x: 350, y: 400},
                ink: 100,
                obstacles: [
                    {x: 200, y: 200, w: 200, h: 20, type: 'solid'}
                ],
                stars: [{x: 250, y: 150}, {x: 350, y: 300}]
            },
            // Level 3: The Gap
            {
                start: {x: 50, y: 100},
                goal: {x: 350, y: 100},
                ink: 150,
                obstacles: [
                    {x: 0, y: 300, w: 400, h: 20, type: 'spike'}, // Floor is lava
                    {x: 180, y: 0, w: 40, h: 200, type: 'solid'} // Wall in middle
                ],
                stars: [{x: 200, y: 250}, {x: 50, y: 300}, {x: 350, y: 200}]
            },
            // Level 4: The Funnel
            {
                start: {x: 200, y: 50},
                goal: {x: 200, y: 550},
                ink: 120,
                obstacles: [
                    {x: 0, y: 300, w: 150, h: 20, type: 'solid'},
                    {x: 250, y: 300, w: 150, h: 20, type: 'solid'},
                    {x: 150, y: 500, w: 100, h: 20, type: 'spike'}
                ],
                stars: [{x: 200, y: 250}, {x: 100, y: 400}, {x: 300, y: 400}]
            },
            // Level 5: The Cavern
            {
                start: {x: 50, y: 50},
                goal: {x: 350, y: 550},
                ink: 200,
                obstacles: [
                    {x: 100, y: 150, w: 200, h: 20, type: 'solid'},
                    {x: 0, y: 350, w: 200, h: 20, type: 'solid'},
                    {x: 250, y: 450, w: 150, h: 20, type: 'spike'},
                    {x: 350, y: 0, w: 20, h: 300, type: 'solid'}
                ],
                stars: [{x: 50, y: 250}, {x: 250, y: 250}, {x: 350, y: 500}]
            }
        ];

        // --- Initialization ---
        
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
        }

        window.addEventListener('resize', resize);
        resize();

        function loadLevel(idx) {
            if (idx >= levels.length) idx = 0; // Loop back or show end game
            currentLevel = idx;
            const data = levels[idx];
            
            // Scale positions relative to screen size (basic responsive logic)
            // We design for roughly 400x600, so we scale
            const scaleX = width > 600 ? 1 : width / 400;
            const scaleY = height > 800 ? 1 : height / 600; 

            ball = new Ball(data.start.x * scaleX, data.start.y * scaleY);
            goal = new Goal(data.goal.x * scaleX, data.goal.y * scaleY);
            
            inkRemaining = data.ink;
            document.getElementById('ink-bar-fill').style.width = '100%';
            document.getElementById('level-display').innerText = idx + 1;
            
            // Clear previous
            walls = [];
            obstacles = [];
            stars = [];
            particles = [];
            starsCollectedInRun = 0;
            isSimulating = false;
            
            // Setup obstacles
            data.obstacles.forEach(o => {
                obstacles.push(new Obstacle(o.x * scaleX, o.y * scaleY, o.w * scaleX, o.h * scaleY, o.type));
            });

            // Setup stars
            data.stars.forEach(s => {
                stars.push(new Star(s.x * scaleX, s.y * scaleY));
            });

            document.getElementById('drop-btn').innerHTML = '<i class="fas fa-play mr-2"></i> DROP BALL';
            document.getElementById('drop-btn').classList.remove('bg-red-900');
        }

        function startGame() {
            document.getElementById('start-modal').classList.remove('active');
            playMusic();
            loadLevel(0);
            animate();
        }

        // --- Interaction Handlers ---

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return new Vector(clientX - rect.left, clientY - rect.top);
        }

        function startDrawing(e) {
            if (isSimulating) return; // Cant draw while ball is moving
            isDrawing = true;
            lastDrawPos = getPointerPos(e);
        }

        function stopDrawing() {
            isDrawing = false;
            lastDrawPos = null;
        }

        function drawMove(e) {
            if (!isDrawing || isSimulating) return;
            const pos = getPointerPos(e);

            if (lastDrawPos) {
                const dist = pos.dist(lastDrawPos);
                if (dist > 5) { // Only draw if moved enough
                    const inkCost = dist * 0.5; // Cost formula
                    if (inkRemaining >= inkCost) {
                        walls.push(new Wall(lastDrawPos.x, lastDrawPos.y, pos.x, pos.y));
                        inkRemaining -= inkCost;
                        lastDrawPos = pos;
                        
                        // Update UI
                        const pct = Math.max(0, (inkRemaining / levels[currentLevel].ink) * 100);
                        document.getElementById('ink-bar-fill').style.width = `${pct}%`;
                    } else {
                        // Out of ink visual feedback?
                        stopDrawing();
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', drawMove);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing, {passive: false});
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); drawMove(e); }, {passive: false});
        canvas.addEventListener('touchend', stopDrawing);

        function togglePlay() {
            if (isSimulating) {
                // Reset
                resetBallState();
            } else {
                // Start
                isSimulating = true;
                ball.active = true;
                ball.vel = new Vector(0, 0); // Ensure clean start
                document.getElementById('drop-btn').innerHTML = '<i class="fas fa-stop mr-2"></i> RESET';
                document.getElementById('drop-btn').classList.add('bg-red-900');
            }
        }

        function resetBallState() {
            isSimulating = false;
            ball.reset();
            // Reset stars
            stars.forEach(s => s.collected = false);
            starsCollectedInRun = 0;
            // Note: We do NOT clear walls on simple reset, only on 'Clear Lines' button
            document.getElementById('drop-btn').innerHTML = '<i class="fas fa-play mr-2"></i> DROP BALL';
            document.getElementById('drop-btn').classList.remove('bg-red-900');
        }

        // The button "Clear Lines"
        window.clearLines = function() {
            walls = [];
            resetBallState(); // Also reset ball
            inkRemaining = levels[currentLevel].ink;
            document.getElementById('ink-bar-fill').style.width = '100%';
        }

        function failLevel() {
            document.getElementById('fail-modal').classList.add('active');
            isSimulating = false;
        }

        window.retryLevel = function() {
            document.getElementById('fail-modal').classList.remove('active');
            resetBallState();
        }

        function winLevel() {
            isSimulating = false;
            ball.active = false;
            playSound('win');
            
            const starContainer = document.getElementById('star-display');
            starContainer.innerHTML = '';
            for(let i=0; i<3; i++) {
                if(i < starsCollectedInRun) starContainer.innerHTML += '<i class="fas fa-star"></i>';
                else starContainer.innerHTML += '<i class="far fa-star text-gray-600"></i>';
            }

            document.getElementById('win-modal').classList.add('active');
        }

        window.nextLevel = function() {
            document.getElementById('win-modal').classList.remove('active');
            loadLevel(currentLevel + 1);
        }

        // --- Physics Logic ---

        // Distance from point p to line segment v-w
        function distToSegmentSquared(p, v, w) {
            const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
            if (l2 == 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return (p.x - v.x - t * (w.x - v.x))**2 + (p.y - v.y - t * (w.y - v.y))**2;
        }

        function resolveCollisions() {
            // 1. Collide with User Walls
            // Use simple elastic collision logic
            for (let w of walls) {
                // Check distance
                const distSq = distToSegmentSquared(ball.pos, w.p1, w.p2);
                if (distSq < ball.radius * ball.radius) {
                    // Collision detected
                    // Calculate normal vector of the line
                    let dx = w.p2.x - w.p1.x;
                    let dy = w.p2.y - w.p1.y;
                    let normal = new Vector(-dy, dx).norm();
                    
                    // Ensure normal points towards ball
                    let ballToLine = ball.pos.sub(w.p1);
                    if (ballToLine.dot(normal) < 0) normal = normal.mult(-1);

                    // Reflect velocity: V_new = V_old - 2(V_old . N)N
                    let dot = ball.vel.dot(normal);
                    
                    // Only bounce if moving towards the wall
                    if (dot < 0) {
                        let bounce = ball.vel.sub(normal.mult(2 * dot));
                        ball.vel = bounce.mult(0.8); // 0.8 is bounciness (lose some energy)
                        
                        // Push ball out of wall to prevent sticking
                        ball.pos = ball.pos.add(normal.mult(ball.radius - Math.sqrt(distSq) + 1));
                        
                        playSound('bounce');
                        spawnParticles(ball.pos.x, ball.pos.y, '#0ff');
                    }
                }
            }

            // 2. Collide with Obstacles (AABB vs Circle)
            for (let o of obstacles) {
                // Find closest point on rectangle to circle
                let testX = ball.pos.x;
                let testY = ball.pos.y;

                if (ball.pos.x < o.x) testX = o.x;
                else if (ball.pos.x > o.x + o.w) testX = o.x + o.w;
                
                if (ball.pos.y < o.y) testY = o.y;
                else if (ball.pos.y > o.y + o.h) testY = o.y + o.h;

                let distX = ball.pos.x - testX;
                let distY = ball.pos.y - testY;
                let distance = Math.sqrt(distX*distX + distY*distY);

                if (distance <= ball.radius) {
                    if (o.type === 'spike') {
                        spawnParticles(ball.pos.x, ball.pos.y, '#f00');
                        failLevel();
                        return;
                    }
                    // Solid Block Bounce
                    let normal = new Vector(distX, distY).norm();
                    // Fallback for direct center hit
                    if (distance === 0) normal = new Vector(0, -1);
                    
                    let dot = ball.vel.dot(normal);
                    if (dot < 0) {
                         let bounce = ball.vel.sub(normal.mult(2 * dot));
                        ball.vel = bounce.mult(0.6);
                        ball.pos = ball.pos.add(normal.mult(ball.radius - distance + 1));
                        playSound('bounce');
                    }
                }
            }

            // 3. Goal Check
            if (ball.pos.dist(goal.pos) < goal.radius) {
                winLevel();
            }

            // 4. Star Collection
            for (let s of stars) {
                if (!s.collected && ball.pos.dist(s.pos) < ball.radius + 10) {
                    s.collected = true;
                    starsCollectedInRun++;
                    playSound('star');
                    spawnParticles(s.pos.x, s.pos.y, '#ff0');
                }
            }
        }

        function spawnParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        // --- Main Loop ---

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            // Draw Background Grid (subtle)
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for(let x=0; x<width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,height); }
            for(let y=0; y<height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(width,y); }
            ctx.stroke();

            // Draw Static Elements
            obstacles.forEach(o => o.draw(ctx));
            goal.draw(ctx);
            stars.forEach(s => s.draw(ctx));

            // Draw User Walls
            walls.forEach(w => w.draw(ctx));
            if (isDrawing && lastDrawPos) {
                 // Draw current line segment being drawn
                 // (handled by array push in real time for visuals, but could add preview here)
            }

            // Update & Draw Ball
            if (ball) {
                ball.update();
                ball.draw(ctx);
                if (ball.active) resolveCollisions();
            }

            // Particles
            for(let i=particles.length-1; i>=0; i--) {
                particles[i].update();
                particles[i].draw(ctx);
                if(particles[i].life <= 0) particles.splice(i, 1);
            }

            requestAnimationFrame(animate);
        }

        // Placeholder for music (browsers block autoplay so triggered by start)
        function playMusic() {
            // Optional background drone could go here
        }

        // Initial render waiting for start
        resize();
        ctx.fillStyle = "#fff";
        ctx.font = "20px Rajdhani";
        ctx.textAlign = "center";
        ctx.fillText("Loading Neon Flow...", width/2, height/2);

    </script>
</body>
</html>
